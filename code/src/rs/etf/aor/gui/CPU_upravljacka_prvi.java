/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * CPU_upravljacka_prvi.java
 *
 * Created on 22.09.2010., 10.29.47
 */
package rs.etf.aor.gui;

import java.awt.Graphics;
import java.awt.Point;
import javax.swing.JPanel;
import rs.etf.aor.components.*;

/**
 *
 * @author MB
 */
public class CPU_upravljacka_prvi extends javax.swing.JPanel implements PanelsInfo {

    private JPanel parent;
    private String parentTitle = "CPU_upravljacka_drugi";

    //components
    private Multiplexer mx;
    Counter cnt;
    private And and1, and2;
    private Or or1;
    private Invertor inv1, inv2, inv3;
    private KMADR kmadr1;
    private KMBRANCH kmbranch1;
    private KMOP kmop1;

    //lines
    public Line lines[];

    //kmop lines
    public Line[] kmopLines;

    //kmadr lines
    public Line[] kmadrLines;

    //kmbranch lines
    public Line[] kmbranchLines;

    //dots
    private Junction dot1, dot2, dot3, dot4, dot5;

    //bus
    /** Creates new form CPU_upravljacka_prvi */
    public CPU_upravljacka_prvi(JPanel parent) {
        this.parent = parent;
        initComponents();
        initPictureComponents();
        initLines();
        connectComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/rs/etf/aor/images/CPU_upravljacka_prvi.jpg"))); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel1)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel1)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables

    public String getParentTitle() {
        return parentTitle;
    }

    private void initLines() {
        lines = new Line[36];
        for (int i = 0; i < lines.length; i++) {
            lines[i] = new Line(null, 0, 0, 1);
        }

        kmopLines = new Line[22];
        for (int i = 0; i < kmopLines.length; i++) {
            kmopLines[i] = new Line(kmop1, i, 0, 1);
        }

        kmadrLines = new Line[7];
        for (int i = 0; i < kmadrLines.length; i++) {
            kmadrLines[i] = new Line(kmadr1, i, 0, 1);
        }

        kmbranchLines = new Line[9];
        for (int i = 0; i < kmbranchLines.length; i++) {
            kmbranchLines[i] = new Line(kmbranch1, i, 0, 1);
        }

        //MOVS
        kmopLines[0].addPoint(new Point(90, 115));
        kmopLines[0].addPoint(new Point(90, 127));

        //MOVD
        kmopLines[1].addPoint(new Point(109, 115));
        kmopLines[1].addPoint(new Point(109, 127));

        //HALT
        lines[35].addPoint(new Point(169, 115));
        lines[35].addPoint(new Point(169, 127));

        //regdir
        kmadrLines[3].addPoint(new Point(237, 116));
        kmadrLines[3].addPoint(new Point(237, 127));

        //indreg
        kmadrLines[4].addPoint(new Point(255, 116));
        kmadrLines[4].addPoint(new Point(255, 127));

        //immed
        kmadrLines[5].addPoint(new Point(308, 116));
        kmadrLines[5].addPoint(new Point(308, 127));

        //val00
        kmbranchLines[6].addPoint(new Point(357, 116));
        kmbranchLines[6].addPoint(new Point(357, 127));

        //val34
        kmbranchLines[7].addPoint(new Point(373, 116));
        kmbranchLines[7].addPoint(new Point(373, 127));

        //val9D
        kmbranchLines[8].addPoint(new Point(441, 116));
        kmbranchLines[8].addPoint(new Point(441, 127));

        // GLOBAL
        //brop
        lines[9].addPoint(new Point(252, 245));
        lines[9].addPoint(new Point(260, 245));

        //bradr
        lines[10].addPoint(new Point(252, 263));
        lines[10].addPoint(new Point(260, 263));

        // end GLOBAL

        //brop on mx
        lines[11].addPoint(new Point(246, 245));
        lines[11].addPoint(new Point(252, 245));

        //bradr on mx
        lines[12].addPoint(new Point(246, 263));
        lines[12].addPoint(new Point(252, 263));

        //brop on or
        lines[13].addPoint(new Point(377, 329));
        lines[13].addPoint(new Point(372, 329));
        lines[13].addPoint(new Point(372, 335));
        lines[13].addPoint(new Point(363, 335));

        //bradr on or
        lines[14].addPoint(new Point(377, 342));
        lines[14].addPoint(new Point(363, 342));

        //branch on or
        lines[15].addPoint(new Point(377, 353));
        lines[15].addPoint(new Point(372, 353));
        lines[15].addPoint(new Point(372, 347));
        lines[15].addPoint(new Point(364, 347));

        //or out
        lines[16].addPoint(new Point(343, 342));
        lines[16].addPoint(new Point(312, 342));

        //or1 from dot
        lines[17].addPoint(new Point(312, 342));
        lines[17].addPoint(new Point(312, 333));
        lines[17].addPoint(new Point(305, 333));

        //or2 from dot
        lines[18].addPoint(new Point(312, 342));
        lines[18].addPoint(new Point(312, 349));
        lines[18].addPoint(new Point(310, 349));

        //run
        lines[19].addPoint(new Point(334, 311));
        lines[19].addPoint(new Point(327, 311));
        lines[19].addPoint(new Point(327, 322));

        //run1 from dot
        lines[20].addPoint(new Point(327, 322));
        lines[20].addPoint(new Point(305, 322));

        //run2 from dot
        lines[21].addPoint(new Point(327, 322));
        lines[21].addPoint(new Point(327, 355));
        lines[21].addPoint(new Point(305, 355));

        //halt
        lines[22].addPoint(new Point(335, 371));
        lines[22].addPoint(new Point(320, 371));
        lines[22].addPoint(new Point(320, 361));

        //halt1 from dot
        lines[23].addPoint(new Point(320, 361));
        lines[23].addPoint(new Point(310, 361));

        //halt2 from dot
        lines[24].addPoint(new Point(320, 361));
        lines[24].addPoint(new Point(320, 328));
        lines[24].addPoint(new Point(310, 328));

        //ld
        lines[25].addPoint(new Point(282, 328));
        lines[25].addPoint(new Point(275, 328));
        lines[25].addPoint(new Point(275, 332));
        lines[25].addPoint(new Point(246, 332));

        //inc
        lines[26].addPoint(new Point(282, 355));
        lines[26].addPoint(new Point(275, 355));
        lines[26].addPoint(new Point(275, 350));
        lines[26].addPoint(new Point(246, 350));

        //inv1->and1
        lines[27].addPoint(new Point(310, 327));
        lines[27].addPoint(new Point(310, 327));

        //inv2->an2
        lines[28].addPoint(new Point(310, 349));
        lines[28].addPoint(new Point(310, 349));

        //inv3->and2
        lines[29].addPoint(new Point(310, 360));
        lines[29].addPoint(new Point(310, 360));

        //op
        lines[30].addPoint(new Point(129, 178));
        lines[30].addPoint(new Point(129, 200));
        lines[30].addPoint(new Point(159, 200));
        lines[30].addPoint(new Point(159, 234));
        lines[30].setThikness(8);

        //adr
        lines[31].addPoint(new Point(265, 178));
        lines[31].addPoint(new Point(265, 211));
        lines[31].addPoint(new Point(191, 211));
        lines[31].addPoint(new Point(191, 234));
        lines[31].setThikness(8);

        //br
        lines[32].addPoint(new Point(401, 178));
        lines[32].addPoint(new Point(401, 219));
        lines[32].addPoint(new Point(222, 219));
        lines[32].addPoint(new Point(222, 234));
        lines[32].setThikness(8);

        //mpout
        lines[33].addPoint(new Point(176, 274));
        lines[33].addPoint(new Point(176, 322));
        lines[33].setThikness(8);

        //cnt out
        lines[34].addPoint(new Point(176, 361));
        lines[34].addPoint(new Point(176, 417));
        lines[34].setThikness(8);

    }

    private void initPictureComponents() {
        and1 = new And(3);
        and2 = new And(3);
        or1 = new Or(3);
        inv1 = new Invertor();
        inv2 = new Invertor();
        inv3 = new Invertor();
        mx = new Multiplexer(2);
        cnt = new Counter(0);
        dot1 = new Junction(2);
        dot2 = new Junction(2);
        dot3 = new Junction(2);
        dot4 = new Junction(3);
        dot5 = new Junction(2);

        kmop1 = new KMOP(22, this);
        kmadr1 = new KMADR(7);
        kmbranch1 = new KMBRANCH(9);
    }

    private void connectComponents() {
        lines[9].setNextComp(dot1);
        dot1.setLine(lines[11], 0);
        dot1.setLine(lines[13], 1);

        lines[10].setNextComp(dot2);
        dot2.setLine(lines[12], 0);
        dot2.setLine(lines[14], 1);

        lines[11].setNextComp(mx);
        lines[11].setNextCompPort(4);
        lines[12].setNextComp(mx);
        lines[12].setNextCompPort(5);

        lines[13].setNextComp(or1);
        lines[13].setNextCompPort(0);
        lines[14].setNextComp(or1);
        lines[14].setNextCompPort(1);
        lines[15].setNextComp(or1);
        lines[15].setNextCompPort(2);

        or1.setLine(lines[16], 0);
        lines[16].setNextComp(dot5);
        dot5.setLine(lines[17], 0);
        dot5.setLine(lines[18], 1);

        lines[17].setNextComp(and1);
        lines[17].setNextCompPort(2);

        lines[18].setNextComp(inv2);
        inv2.setLine(lines[28], 0);
        lines[28].setNextComp(and2);
        lines[28].setNextCompPort(0);

        lines[19].setNextComp(dot3);
        dot3.setLine(lines[20], 0);
        dot3.setLine(lines[21], 1);

        lines[20].setNextComp(and1);
        lines[20].setNextCompPort(0);
        lines[21].setNextComp(and2);
        lines[21].setNextCompPort(1);

        lines[22].setNextComp(dot4);
        dot4.setLine(lines[23], 0);
        dot4.setLine(lines[24], 1);
        dot4.setLine(lines[35], 2);

        lines[23].setNextComp(inv3);
        inv3.setLine(lines[27], 0);
        lines[27].setNextComp(and1);
        lines[27].setNextCompPort(1);

        lines[24].setNextComp(inv1);
        inv1.setLine(lines[29], 0);
        lines[29].setNextComp(and2);
        lines[29].setNextCompPort(2);

        and1.setLine(lines[25], 0);
        and2.setLine(lines[26], 0);

        lines[25].setNextComp(cnt);
        lines[25].setNextCompPort(1);
        lines[26].setNextComp(cnt);
        lines[26].setNextCompPort(3);

        lines[30].setNextComp(mx);
        lines[30].setNextCompPort(2);
        lines[31].setNextComp(mx);
        lines[31].setNextCompPort(1);
        lines[32].setNextComp(mx);
        lines[32].setNextCompPort(0);

        mx.setLine(lines[33], 0);
        lines[33].setNextComp(cnt);
        lines[33].setNextCompPort(0);

        cnt.setLine(lines[34], 0);
        lines[34].addTextPoint(new Point(194, 395));

        kmop1.setLine(lines[30], 0);

        kmadr1.setLine(lines[31], 0);

        kmbranch1.setLine(lines[32], 0);

    }

    public void paint(Graphics g) {
        super.paint(g);
        for (int i = 0; i < lines.length; i++) {
            lines[i].paint(g);
        }
        for (int i = 0; i < kmopLines.length; i++) {
            kmopLines[i].paint(g);
        }

        for (int i = 0; i < kmadrLines.length; i++) {
            kmadrLines[i].paint(g);
        }

        for (int i = 0; i < kmbranchLines.length; i++) {
            kmbranchLines[i].paint(g);
        }
    }

    public void refreshSequential() {
        cnt.refreshSequential();
    }

    public void clock() {
        cnt.clock();
    }

    public void clear() {
        if (lines[35].getValue() == 1) {
            cnt.setState(0x0);
        } else {
            cnt.setState(0xffff);
        }
    }

    public int getT() {
        return lines[34].getValue();
    }
    /*
    //returns hex code of operation
    public int getOpHexCode(String op) {
    if (op.equals("MOVS")) {
    return 0x3E;
    }
    if (op.equals("RTS")) {
    return 0x65;
    }
    if (op.equals("MOVD")) {
    return 0x41;
    }
    if (op.equals("INT")) {
    return 0x6D;
    }
    if (op.equals("ADD")) {
    return 0x45;
    }
    if (op.equals("PUSH")) {
    return 0x6F;
    }
    if (op.equals("AND")) {
    return 0x49;
    }
    if (op.equals("POP")) {
    return 0x76;
    }
    if (op.equals("ASR")) {
    return 0x4D;
    }
    if (op.equals("INC")) {
    return 0x82;
    }
    if (op.equals("BNZ")) {
    return 0x51;
    }
    if (op.equals("DEC")) {
    return 0x86;
    }
    if (op.equals("JSR")) {
    return 0x56;
    }
    if (op.equals("INTE")) {
    return 0x8A;
    }
    if (op.equals("JMP")) {
    return 0x5C;
    }
    if (op.equals("INTD")) {
    return 0x8C;
    }
    if (op.equals("JMPIND")) {
    return 0x5E;
    }
    if (op.equals("TRPE")) {
    return 0x8E;
    }
    if (op.equals("RTI")) {
    return 0x61;
    }
    if (op.equals("TRPD")) {
    return 0x90;
    }
    if (op.equals("HALT")) {
    return 0x92;
    }

    //badopcode
    return 0xFF;
    }

    //returns hex code of way of addressing
    public int getWayOfAddressingHex(String adr){
    int ind = adr.lastIndexOf(" ");
    adr.substring(0, ind);

    if (adr.equals("regdir")) {
    return 0x1B;
    }
    if (adr.equals("indreg")) {
    return 0x1D;
    }
    if (adr.equals("indregpom")) {
    return 0x1F;
    }
    if (adr.equals("dirmem")) {
    return 0x23;
    }
    if (adr.equals("indmem")) {
    return 0x25;
    }
    if (adr.equals("rel")) {
    return 0x2E;
    }
    if (adr.equals("immed")) {
    return 0x32;
    }

    //badway
    return 0xFF;
    }

     */
}
